Arborescence du projet :
.
├── backend
│   ├── chat
│   │   ├── admin.py
│   │   ├── apps.py
│   │   ├── __init__.py
│   │   ├── migrations
│   │   │   └── __init__.py
│   │   ├── models.py
│   │   ├── tests.py
│   │   └── views.py
│   ├── conecte_me_backend
│   │   ├── __init__.py
│   │   ├── middleware.py
│   │   ├── settings.py
│   │   ├── urls.py
│   │   ├── views.py
│   │   └── wsgi.py
│   ├── Dockerfile
│   ├── logs
│   │   ├── django.log
│   │   ├── django.log.2025-03-04
│   │   └── frontend.log
│   ├── manage.py
│   ├── media
│   │   └── profile_pictures
│   │       └── default_avatar.png
│   ├── oauth_app
│   │   ├── __init__.py
│   │   ├── migrations
│   │   │   ├── 0001_initial.py
│   │   │   ├── 0002_user42_email_address_user42_first_name_and_more.py
│   │   │   ├── 0003_user42_is_2fa_enabled_user42_totp_secret.py
│   │   │   ├── 0004_alter_user42_totp_secret.py
│   │   │   ├── 0005_user42_profile_image.py
│   │   │   ├── 0006_alter_user42_profile_image_userloginhistory.py
│   │   │   ├── 0007_userloginhistory_is_connected.py
│   │   │   └── __init__.py
│   │   ├── models.py
│   │   ├── templates
│   │   │   └── 2fa_setup.html
│   │   ├── tests.py
│   │   ├── twofa_views.py
│   │   ├── urls.py
│   │   ├── utils.py
│   │   └── views.py
│   └── requirements.txt
├── certs
│   ├── localhost.crt
│   └── localhost.key
├── docker-compose.yml
├── elk
│   ├── elasticsearch
│   │   └── elasticsearch.yml
│   ├── elk_initializer.sh
│   ├── filebeat.yml
│   ├── kibana
│   │   └── kibana.yml
│   ├── logstash
│   │   ├── logstash.conf
│   │   └── logstash.yml
│   └── saved_objects.ndjson
├── frontend
│   ├── Dockerfile
│   ├── index.html
│   └── static
│       ├── css
│       │   ├── board.css
│       │   ├── login.css
│       │   ├── main.css
│       │   ├── privacy.css
│       │   ├── setup.css
│       │   ├── signup.css
│       │   ├── stats.css
│       │   ├── team.css
│       │   ├── terms.css
│       │   └── user.css
│       ├── fonts
│       │   ├── PongGame.woff
│       │   └── PongGame.woff2
│       ├── img
│       │   ├── 42_logo.png
│       │   ├── default_avatar.png
│       │   ├── favicon.ico
│       │   ├── Game_anime.png
│       │   ├── jecointr.jpg
│       │   ├── mmaric.jpg
│       │   ├── ode-cleb.jpg
│       │   ├── PONG_Accueil.png
│       │   ├── PONG_seul.png
│       │   ├── raveriss.jpg
│       │   ├── return_arrow.png
│       │   ├── sycourbi.jpg
│       │   └── Symbole_return.png
│       ├── js
│       │   ├── 2fa.js
│       │   ├── board.js
│       │   ├── login.js
│       │   ├── main.js
│       │   ├── router.js
│       │   ├── setup.js
│       │   ├── signin42.js
│       │   ├── signup.js
│       │   └── user.js
│       └── templates
│           ├── board.html
│           ├── home.html
│           ├── login.html
│           ├── privacy.html
│           ├── setup.html
│           ├── signin42.html
│           ├── signup.html
│           ├── stats.html
│           ├── team.html
│           ├── terms.html
│           └── user.html
├── nginx.conf
├── output.log
└── README.md

22 directories, 96 files

--- Fin de l'arborescence ---


--- Nginx ---

events {
    worker_connections 1024;
}

http {
    include       mime.types;
    default_type  application/octet-stream;

    # Logs
    access_log /var/log/nginx/access.log;
    error_log /var/log/nginx/error.log warn;

    server {
        listen 443 ssl;
        server_name 10.31.5.3;

        ssl_certificate     /etc/nginx/certs/localhost.crt;
        ssl_certificate_key /etc/nginx/certs/localhost.key;
        ssl_session_cache shared:SSL:10m;
        ssl_session_timeout 10m;
        ssl_protocols TLSv1.2 TLSv1.3;
        ssl_ciphers HIGH:!aNULL:!MD5;

        location /static/ {
            proxy_pass http://conecteme_frontend:80/static/;
        }

        location ~* \.(html|htm|css|js|png|jpg|jpeg|gif|ico)$ {
            proxy_pass http://conecteme_frontend:80;
        }

        location /auth/ {
            proxy_set_header Host $host;
            proxy_pass http://conecteme_backend:8000;
        }

        location /api/ {
            proxy_set_header Host $host;
            proxy_pass http://conecteme_backend:8000;
        }
        
        location ^~ /media/ {
            alias /app/media/;
        }

        # Pour la SPA : redirige vers index.html si le fichier n’existe pas
        location / {
            try_files $uri /index.html;
        }


    }

    server {
        listen 80;
        server_name localhost;
        return 301 https://$host$request_uri;
    }
}

--- Frontend ---

# backend/oauth_app/twofa_views.py
import io
import base64
import pyotp
import qrcode
from django.shortcuts import render, redirect
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from .models import User42, UserLoginHistory

# Optionnel : Limitation des tentatives brute force
MAX_2FA_ATTEMPTS = 5

def get_current_user(request):
    """Récupère l'utilisateur connecté via la session."""
    user_id = request.session.get('user_id')
    if not user_id:
        return None
    try:
        return User42.objects.get(pk=user_id)
    except User42.DoesNotExist:
        return None

def generate_qr_code_image(uri):
    """Génère un QR Code et retourne l'image encodée en base64."""
    qr = qrcode.make(uri)
    buffered = io.BytesIO()
    qr.save(buffered, format="PNG")
    img_str = base64.b64encode(buffered.getvalue()).decode("utf-8")
    return img_str

def two_factor_setup(request):
    """
    Affiche le QR Code pour configurer l'authentification 2FA.
    Si le secret TOTP n'existe pas encore pour l'utilisateur, il est créé.
    """
    user = get_current_user(request)
    if not user:
        return redirect('/auth/login/')
    
    # Si le 2FA est déjà activé, rediriger directement vers l'interface de jeu
    # if user.is_2fa_enabled:
    #     return redirect('/board.html')
    
    # Générer le secret TOTP s'il n'existe pas déjà
    if not user.totp_secret:
        user.totp_secret = pyotp.random_base32()
        user.save()
    
    # Création de l'URI de provisioning pour Google Authenticator
    otp = pyotp.TOTP(user.totp_secret)
    provisioning_uri = otp.provisioning_uri(name=user.email_address, issuer_name="ConecteMe")
    
    # Génération du QR Code encodé en base64
    qr_code_base64 = generate_qr_code_image(provisioning_uri)
    
    return render(request, "2fa_setup.html", {"qr_code": qr_code_base64})

@csrf_exempt
def two_factor_validate(request):
    """
    Valide le code TOTP envoyé par l'utilisateur.
    En cas de succès, active le 2FA, enregistre la connexion et renvoie une réponse JSON avec redirection.
    """
    user = get_current_user(request)
    if not user:
        return JsonResponse({"success": False, "error": "Utilisateur non authentifié."}, status=401)
    
    if request.method == 'POST':
        otp_code = request.POST.get('otp_code')
        if not otp_code:
            return JsonResponse({"success": False, "error": "Le code OTP est requis."}, status=400)
        
        # Limiter le nombre de tentatives pour contrer le bruteforce
        attempts = request.session.get('2fa_attempts', 0)
        if attempts >= MAX_2FA_ATTEMPTS:
            return JsonResponse({"success": False, "error": "Nombre maximum de tentatives atteint."}, status=429)
        
        totp = pyotp.TOTP(user.totp_secret)
        if totp.verify(otp_code, valid_window=1):  # valid_window permet un léger décalage
            user.is_2fa_enabled = True
            user.save()
            request.session['2fa_attempts'] = 0  # Réinitialisation du compteur de tentatives
            
            # --- Enregistrement de la connexion 2FA ---
            ip_address = request.META.get('REMOTE_ADDR')
            user_agent = request.META.get('HTTP_USER_AGENT', '')
            UserLoginHistory.objects.create(
                user=user,
                ip_address=ip_address,
                user_agent=user_agent,
                is_connected=True
            )
            
            return JsonResponse({
                "success": True,
                "message": "2FA validé avec succès.",
                "redirect": "/board"
            }, status=200)
        else:
            request.session['2fa_attempts'] = attempts + 1
            return JsonResponse({"success": False, "error": "Code OTP invalide."}, status=400)
    else:
        return JsonResponse({"success": False, "error": "Méthode non autorisée."}, status=405)
# backend/oauth_app/urls.py
from django.urls import path
from .views import (
    redirect_to_42,
    callback_42,
    signup_view,
    login_view,
    user_info,  # <--- Import de la nouvelle vue
    upload_avatar_view,
    set_42_password_view,
    update_email_view,  # Import de la nouvelle vue
    update_password_view,
    export_data_view,
    delete_account_view,
    user_login_history,
    update_login_status,
)
from . import twofa_views, views

urlpatterns = [
    path('signup/', signup_view, name='signup'),
    path('login/', login_view, name='login'),
    path('login-42/', redirect_to_42, name='redirect_to_42'),
    path('callback', callback_42, name='callback_42'),
    # path('42/password/', set_42_password_view, name='set_42_password'),  # <== Ajouté ici

    path('2fa/setup/', twofa_views.two_factor_setup, name='two_factor_setup'),
    path('2fa/validate/', twofa_views.two_factor_validate, name='two_factor_validate'),
    path('user/toggle_2fa/', views.toggle_2fa, name='toggle_2fa'),

    # Nouvelle route pour récupérer le username
    path('user/', user_info, name='user_info'),

    path('user/upload_avatar/', upload_avatar_view, name='upload_avatar'),
    path('user/update_email/', update_email_view, name='update_email'),
    path("user/update_password/", update_password_view, name="update_password"),
    path('user/export_data/', export_data_view, name='export_data'),
    path('user/delete_account/', delete_account_view, name='delete_account'),

    path('user/login_history/', user_login_history, name='user_login_history'),
    path('user/update_login_status/', update_login_status, name='update_login_status'),
    path('logout/', views.logout_view, name='logout'),
]
import os
import requests
import jwt
import datetime
import requests
import json
import re


from django.shortcuts import redirect, render
from django.http import JsonResponse, HttpResponseRedirect
from django.urls import reverse
from django.utils.crypto import get_random_string
from django.views.decorators.csrf import csrf_exempt
from django.contrib.auth.hashers import check_password, make_password
from django.db import IntegrityError, transaction
from .models import User42, UserLoginHistory


from django.middleware.csrf import get_token
from django.contrib import messages

from .models import User42, UserLoginHistory
from .utils import generate_jwt

# Ajout de la gestion des logs
import logging
logger = logging.getLogger(__name__)

# Récupération des variables d'env
CLIENT_ID = os.environ.get('OAUTH42_CLIENT_ID')
CLIENT_SECRET = os.environ.get('OAUTH42_CLIENT_SECRET')
REDIRECT_URI = os.environ.get('OAUTH42_REDIRECT_URI')
TOKEN_URL = "https://api.intra.42.fr/oauth/token"
AUTHORIZE_URL = "https://api.intra.42.fr/oauth/authorize"

def redirect_to_42(request):
    """
    Redirige vers la page d'authentification 42 en utilisant
    Authorization Code Grant. On génère un state random pour la protection CSRF.
    """
    state = get_random_string(32)
    request.session['oauth_state'] = state

    params = {
        'client_id': CLIENT_ID,
        'redirect_uri': REDIRECT_URI,
        'response_type': 'code',
        'scope': 'public',
        'state': state,
    }
    # Construction de l'URL d'authentification
    query_string = "&".join([f"{k}={v}" for k, v in params.items()])
    auth_url = f"{AUTHORIZE_URL}?{query_string}"
    return redirect(auth_url)


def callback_42(request):
    # Vérification du state et récupération du code OAuth (code déjà présent)
    code = request.GET.get('code')
    if not code:
        return JsonResponse({"error": "No code provided"}, status=400)

    # Échange du code contre un access token
    data = {
        'grant_type': 'authorization_code',
        'client_id': CLIENT_ID,
        'client_secret': CLIENT_SECRET,
        'code': code,
        'redirect_uri': REDIRECT_URI,
    }
    try:
        token_response = requests.post(TOKEN_URL, data=data)
        token_data = token_response.json()
        access_token = token_data.get('access_token')
        if not access_token:
            return JsonResponse({"error": "Failed to retrieve access token"}, status=400)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=400)

    # Récupération des infos utilisateur depuis l'API 42
    user_info_url = "https://api.intra.42.fr/v2/me"
    headers = {
        'Authorization': f"Bearer {access_token}"
    }
    user_resp = requests.get(user_info_url, headers=headers)
    if user_resp.status_code != 200:
        return JsonResponse({"error": "Failed to retrieve user info"}, status=400)
    user_data = user_resp.json()  # Maintenant, user_resp est défini

    user_id_42 = user_data['id']
    user_name_42 = user_data['login']
    email_from_api = user_data.get('email')
    first_name_from_api = user_data.get('first_name')
    email_value = email_from_api if email_from_api else 'placeholder@example.com'
    first_name_value = first_name_from_api if first_name_from_api else 'Unknown'

    # Définir le mot de passe par défaut (haché)
    default_password = make_password("42sch@@L")

    try:
        with transaction.atomic():
            # Recherche de l'utilisateur par email (champ unique dans notre cas)
            user = User42.objects.filter(email_address=email_value).first()
            if user:
                # Mise à jour des informations si nécessaire
                if (email_from_api and email_from_api != user.email_address) or \
                   (first_name_from_api and first_name_from_api != user.first_name):
                    user.email_address = email_from_api or user.email_address
                    user.first_name = first_name_from_api or user.first_name
                # Affectation du mot de passe par défaut haché
                user.password = default_password
                user.is_connected = True
                user.save()
            else:
                # Attribution d'un user_id unique
                existing_ids = list(User42.objects.values_list('user_id', flat=True))
                sorted_ids = sorted(existing_ids)
                new_user_id = 0
                for uid in sorted_ids:
                    if uid == new_user_id:
                        new_user_id += 1
                    else:
                        break

                # Création d'un nouvel utilisateur avec le mot de passe par défaut
                user = User42(
                    user_id=new_user_id,
                    username=user_name_42,
                    email_address=email_value,
                    first_name=first_name_value,
                    password=default_password  # Mot de passe haché
                )
                user.save()
    except IntegrityError:
        return JsonResponse({"error": "Erreur lors de l'inscription de l'utilisateur"}, status=400)

    # Mise à jour de la session pour que checkAuth détecte l'utilisateur authentifié
    request.session['user_id'] = user.pk
    request.session['email'] = user.email_address

    # Mise à jour de la session, création du log de connexion, etc.
    jwt_token = generate_jwt(user_id=user_id_42, username=user_name_42)
    response = HttpResponseRedirect(f"https://10.31.5.3:8443/board?jwt={jwt_token}")
    return response

# --- Vue d'inscription modifiée pour gérer l'upload de l'image de profil ---
@csrf_exempt
def signup_view(request):
    if request.method == 'POST':
        # Récupération des données du formulaire
        first_name   = request.POST.get('first_name')
        email        = request.POST.get('email_address')
        raw_password = request.POST.get('password')
        pseudo       = request.POST.get('username', '')

        # Vérification que tous les champs requis sont présents
        if not all([first_name, email, raw_password]):
            return JsonResponse(
                {"success": False, "error": "Tous les champs requis ne sont pas remplis."},
                status=400
            )

        # Gestion de l'image de profil
        profile_image = request.FILES.get('avatar')
        if profile_image:
            # Limiter la taille du fichier à 2MB
            if profile_image.size > 2 * 1024 * 1024:
                return JsonResponse(
                    {"success": False, "error": "La taille de l'image ne doit pas dépasser 2MB."},
                    status=400
                )
            # Vérifier le type MIME (seuls JPEG et PNG sont acceptés)
            if profile_image.content_type not in ['image/jpeg', 'image/png']:
                return JsonResponse(
                    {"success": False, "error": "Format d'image non supporté. Seul JPEG et PNG sont autorisés."},
                    status=400
                )

        try:
            with transaction.atomic():
                # Récupérer tous les user_id existants
                existing_ids = list(User42.objects.values_list('user_id', flat=True))
                # Trier les IDs pour faciliter la recherche de la plus petite valeur manquante
                sorted_ids = sorted(existing_ids)

                # Déterminer le plus petit user_id disponible
                new_user_id = 0
                for uid in sorted_ids:
                    if uid == new_user_id:
                        new_user_id += 1
                    else:
                        # Dès qu'on trouve un gap, on arrête : new_user_id est disponible
                        break

                # Création de l'utilisateur avec le user_id trouvé
                user = User42(
                    user_id=new_user_id,
                    username=pseudo or email.split('@')[0],
                    first_name=first_name,
                    email_address=email,
                )
                user.password = make_password(raw_password)
                if profile_image:
                    user.profile_image = profile_image
                user.save()

        except IntegrityError:
            # Gestion propre des erreurs transactionnelles pour éviter les conflits d'unicité
            return JsonResponse(
                {"success": False, "error": "Cette adresse e-mail est déjà utilisée."},
                status=400
            )

        return JsonResponse(
            {"success": True, "detail": "Inscription réussie."},
            status=201
        )

    return JsonResponse(
        {"success": False, "error": "Méthode non autorisée."},
        status=405
    )

@csrf_exempt
def logout_view(request):
    """
    Vue de déconnexion qui met à jour is_connected à False,
    puis nettoie la session et redirige vers /home.
    """
    user_id = request.session.get('user_id')
    if user_id:
        try:
            user = User42.objects.get(pk=user_id)
            # Mise à jour du dernier log de connexion
            last_login = UserLoginHistory.objects.filter(user=user).order_by('-timestamp').first()
            if last_login:
                last_login.is_connected = False
                last_login.save()
        except User42.DoesNotExist:
            pass

    request.session.flush()
    return JsonResponse({"success": True, "redirect": "/home"}, status=200)

@csrf_exempt
def user_login_history(request):
    user_id = request.session.get('user_id')
    if not user_id:
        return JsonResponse({'error': 'User not authenticated'}, status=401)
    try:
        user = User42.objects.get(pk=user_id)
    except User42.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)

    # Récupérer les 3 dernières connexions
    logs = UserLoginHistory.objects.filter(user=user)[:3]
    data = [
        {
            'timestamp': log.timestamp.isoformat(),
            'ip_address': log.ip_address,
            'user_agent': log.user_agent,
            'is_connected': log.is_connected  # Conversion de 't' en booléen
        }
        for log in logs
    ]
    return JsonResponse({'login_history': data})


@csrf_exempt
def login_view(request):
    if request.method == 'POST':
        email = request.POST.get('email')
        password = request.POST.get('password')

        if not email or not password:
            return JsonResponse({
                "success": False,
                "error": "Champs 'email' et 'password' requis."
            }, status=400)

        user = User42.objects.filter(email_address=email).first()
        if not user:
            return JsonResponse({
                "success": False,
                "error": "Email ou mot de passe incorrect."
            }, status=401)

        if check_password(password, user.password):
            # Authentification réussie : mise à jour de la session
            request.session['user_id'] = user.pk
            request.session['email'] = user.email_address

            # Si 2FA n'est pas encore activé, rediriger vers la configuration 2FA
            if user.is_2fa_enabled:
                return JsonResponse({
                    "success": True,
                    "redirect": "/auth/2fa/setup/"
                }, status=200)
            else:
                ip_address = request.META.get('REMOTE_ADDR')
                user_agent = request.META.get('HTTP_USER_AGENT', '')
                UserLoginHistory.objects.create(
                    user=user,
                    ip_address=ip_address,
                    user_agent=user_agent,
                    is_connected=True
                )
                return JsonResponse({
                    "success": True,
                    "redirect": "/board"
                }, status=200)

        return JsonResponse({
            "success": False,
            "error": "Email ou mot de passe incorrect."
        }, status=401)
    
    return JsonResponse({
        "success": False,
        "error": "Méthode non autorisée."
    }, status=405)

# -------------------------------
# Nouvelle vue pour récupérer le username
# -------------------------------
def user_info(request):
    logger.debug("Appel de user_info, session: %s", dict(request.session))
    user_id = request.session.get('user_id')
    if not user_id:
        logger.error("Aucun user_id dans la session !")
        return JsonResponse({'error': 'User not authenticated'}, status=401)
    try:
        user = User42.objects.get(pk=user_id)
        logger.debug("Utilisateur trouvé : %s", user.username)
        return JsonResponse({
            'username': user.username,
            'profile_image': user.profile_image.url,
            'is_2fa_enabled': user.is_2fa_enabled  # Ajouté ici
        })
    except User42.DoesNotExist:
        logger.error("Utilisateur non trouvé pour user_id=%s", user_id)
        return JsonResponse({'error': 'User not found'}, status=404)
    
@csrf_exempt
def upload_avatar_view(request):
    if request.method == 'POST':
        # Vérification de l'authentification via la session
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({"success": False, "error": "Utilisateur non authentifié."}, status=401)
        try:
            user = User42.objects.get(pk=user_id)
        except User42.DoesNotExist:
            return JsonResponse({"success": False, "error": "Utilisateur non trouvé."}, status=404)

        # Récupération du fichier envoyé
        avatar_file = request.FILES.get('avatar')
        if not avatar_file:
            return JsonResponse({"success": False, "error": "Aucun fichier envoyé."}, status=400)

        # Vérification de la taille (max 2MB)
        if avatar_file.size > 2 * 1024 * 1024:
            return JsonResponse({"success": False, "error": "La taille de l'image ne doit pas dépasser 2MB."}, status=400)
        # Vérification du format (JPEG/PNG)
        if avatar_file.content_type not in ['image/jpeg', 'image/png']:
            return JsonResponse({"success": False, "error": "Format d'image non supporté."}, status=400)

        # Sauvegarde du nouvel avatar dans le modèle (le champ profile_image gère le chemin d'upload)
        user.profile_image = avatar_file
        user.save()

        # Retour de l'URL de la nouvelle image pour mise à jour immédiate côté client
        return JsonResponse({"success": True, "profile_image_url": user.profile_image.url}, status=200)
    else:
        return JsonResponse({"success": False, "error": "Méthode non autorisée."}, status=405)
    
@csrf_exempt
def set_42_password_view(request):
    """
    Réception du mot de passe saisi par l’utilisateur lors de sa première connexion via 42.
    Le mot de passe est validé, haché et stocké temporairement dans la session.
    """
    if request.method == 'POST':
        password = request.POST.get('password')
        confirm = request.POST.get('confirmPassword')

        if not password or not confirm or password != confirm:
            return JsonResponse({"success": False, "error": "Les mots de passe ne correspondent pas."}, status=400)

        # Vérification côté serveur : minimum 8 caractères, 1 majuscule, 1 chiffre, 1 caractère spécial
        pattern = r'^(?=.*[A-Z])(?=.*\d)(?=.*[^A-Za-z0-9]).{8,}$'
        if not re.match(pattern, password):
            return JsonResponse({"success": False, "error": "Le mot de passe ne respecte pas les critères de sécurité."}, status=400)

        # Hachage sécurisé du mot de passe
        hashed_password = make_password(password)
        # Stockage temporaire dans la session
        request.session['temp_hashed_password'] = hashed_password

        return JsonResponse({
            "success": True,
            "detail": "Mot de passe défini avec succès. Vous allez être redirigé vers l'authentification 42."
        }, status=200)
    else:
        return JsonResponse({"success": False, "error": "Méthode non autorisée."}, status=405)
    
@csrf_exempt
def update_email_view(request):
    if request.method != 'POST':
        return JsonResponse({"success": False, "error": "Méthode non autorisée."}, status=405)
    
    # Vérifier que l'utilisateur est authentifié via la session
    user_id = request.session.get('user_id')
    if not user_id:
        return JsonResponse({"success": False, "error": "Utilisateur non authentifié."}, status=401)
    
    try:
        user = User42.objects.get(pk=user_id)
    except User42.DoesNotExist:
        return JsonResponse({"success": False, "error": "Utilisateur non trouvé."}, status=404)
    
    # Extraire le JSON envoyé
    try:
        data = json.loads(request.body)
    except Exception:
        return JsonResponse({"success": False, "error": "JSON invalide."}, status=400)
    
    current_email = data.get('current_email', '').strip()
    new_email = data.get('new_email', '').strip()
    password = data.get('password', '')

    # Vérification que l'email actuel correspond à celui enregistré
    if current_email != user.email_address:
        return JsonResponse({"success": False, "error": "L'email actuel ne correspond pas."}, status=400)
    
    # Vérifier le format du nouvel email
    email_regex = r'^[^\s@]+@[^\s@]+\.[^\s@]+$'
    if not re.match(email_regex, new_email):
        return JsonResponse({"success": False, "error": "Le nouvel email n'est pas valide."}, status=400)
    
    # Vérifier que le nouvel email n'est pas déjà utilisé par un autre compte
    if User42.objects.filter(email_address=new_email).exclude(pk=user_id).exists():
        return JsonResponse({"success": False, "error": "Cet email est déjà utilisé par un autre compte."}, status=400)
    
    # Vérifier que le mot de passe est correct
    if not check_password(password, user.password):
        return JsonResponse({"success": False, "error": "Mot de passe incorrect."}, status=400)
    
    # Tout est validé : mise à jour de l'email
    user.email_address = new_email
    user.save()
    
    # Mettre à jour éventuellement la session
    request.session['email'] = new_email
    
    return JsonResponse({"success": True, "detail": "Email mis à jour avec succès."}, status=200)

@csrf_exempt
def update_password_view(request):
    if request.method != "POST":
        return JsonResponse({"success": False, "error": "Méthode non autorisée."}, status=405)
    
    # Vérifier que l'utilisateur est authentifié via la session
    user_id = request.session.get("user_id")
    if not user_id:
        return JsonResponse({"success": False, "error": "Utilisateur non authentifié."}, status=401)
    
    # Extraction des données JSON
    try:
        data = json.loads(request.body)
    except Exception:
        return JsonResponse({"success": False, "error": "JSON invalide."}, status=400)
    
    current_password = data.get("current_password", "").strip()
    new_password = data.get("new_password", "").strip()
    confirm_password = data.get("confirm_password", "").strip()
    
    # Vérification que tous les champs sont présents
    if not current_password or not new_password or not confirm_password:
        return JsonResponse({"success": False, "error": "Tous les champs sont requis."}, status=400)
    
    # Vérification de la correspondance des nouveaux mots de passe
    if new_password != confirm_password:
        return JsonResponse({"success": False, "error": "Les nouveaux mots de passe ne correspondent pas."}, status=400)
    
    # Vérification des critères de sécurité
    password_pattern = r"^(?=.*[A-Z])(?=.*\d)(?=.*[^A-Za-z0-9]).{8,}$"
    if not re.match(password_pattern, new_password):
        return JsonResponse({"success": False, "error": "Le nouveau mot de passe ne respecte pas les critères de sécurité."}, status=400)
    
    # Récupération de l'utilisateur
    try:
        user = User42.objects.get(pk=user_id)
    except User42.DoesNotExist:
        return JsonResponse({"success": False, "error": "Utilisateur non trouvé."}, status=404)
    
    # Vérification du mot de passe actuel
    if not check_password(current_password, user.password):
        return JsonResponse({"success": False, "error": "Mot de passe actuel incorrect."}, status=400)
    
    # Vérifier que le nouveau mot de passe est différent de l'ancien
    if current_password == new_password:
        return JsonResponse({"success": False, "error": "Votre nouveau mot de passe doit être différent de l'ancien."}, status=400)
    
    # Tout est validé : hachage et mise à jour du mot de passe
    user.password = make_password(new_password)
    user.save()
    
    return JsonResponse({"success": True, "detail": "Mot de passe mis à jour avec succès."}, status=200)

@csrf_exempt
def export_data_view(request):
    """
    Vue permettant d’exporter les données personnelles de l’utilisateur
    au format JSON. La réponse contient un header Content-Disposition afin
    d’indiquer qu’il s’agit d’un fichier téléchargeable.
    """
    if request.method != "GET":
        return JsonResponse({"success": False, "error": "Méthode non autorisée."}, status=405)

    user_id = request.session.get("user_id")
    if not user_id:
        return JsonResponse({"success": False, "error": "Utilisateur non authentifié."}, status=401)

    try:
        user = User42.objects.get(pk=user_id)
    except User42.DoesNotExist:
        return JsonResponse({"success": False, "error": "Utilisateur non trouvé."}, status=404)

    # Préparer les données à exporter
    data = {
        "user_id": user.user_id,
        "username": user.username,
        "email_address": user.email_address,
        "first_name": user.first_name,
        "is_2fa_enabled": user.is_2fa_enabled,
        "profile_image": user.profile_image.url if user.profile_image else "",
        "created_at": user.created_at.isoformat()
    }

    response = JsonResponse(data)
    response['Content-Disposition'] = 'attachment; filename="mes_donnees.json"'
    return response

@csrf_exempt
def delete_account_view(request):
    """
    Vue permettant de supprimer complètement le compte de l’utilisateur.
    Elle supprime l’utilisateur de la table User42 ainsi que les fichiers médias liés,
    nettoie la session et renvoie une réponse JSON confirmant la suppression.
    """
    if request.method != "POST":
        return JsonResponse({"success": False, "error": "Méthode non autorisée."}, status=405)

    user_id = request.session.get("user_id")
    if not user_id:
        return JsonResponse({"success": False, "error": "Utilisateur non authentifié."}, status=401)

    try:
        user = User42.objects.get(pk=user_id)
    except User42.DoesNotExist:
        return JsonResponse({"success": False, "error": "Utilisateur non trouvé."}, status=404)

    # Suppression de l'image de profil si elle n'est pas celle par défaut
    if user.profile_image and user.profile_image.name != 'profile_pictures/default_avatar.png':
        image_path = user.profile_image.path
        if os.path.exists(image_path):
            os.remove(image_path)

    # Supprimer l'utilisateur (et toutes les données associées)
    user.delete()

    # Nettoyer la session
    request.session.flush()

    return JsonResponse({"success": True, "detail": "Compte supprimé avec succès."})

@csrf_exempt
def update_login_status(request):
    if request.method == "POST":
        user_id = request.session.get('user_id')
        if not user_id:
            logger.error("Aucun user_id dans la session")
            return JsonResponse({"success": False, "error": "Utilisateur non authentifié."}, status=401)
        
        try:
            user = User42.objects.get(pk=user_id)
        except User42.DoesNotExist:
            logger.error("Utilisateur non trouvé pour user_id=%s", user_id)
            return JsonResponse({"success": False, "error": "Utilisateur non trouvé."}, status=404)
        
        try:
            data = json.loads(request.body)
            is_connected = data.get('is_connected', False)
            if not isinstance(is_connected, bool):
                logger.error("'is_connected' n'est pas un booléen: %s", data.get('is_connected'))
                return JsonResponse({"success": False, "error": "'is_connected' doit être un booléen."}, status=400)
        except json.JSONDecodeError:
            logger.error("Données mal formatées: %s", request.body)
            return JsonResponse({"success": False, "error": "Données mal formatées."}, status=400)
        
        last_login = UserLoginHistory.objects.filter(user=user).order_by('-timestamp').first()
        if last_login:
            logger.info("Mise à jour du log id=%s pour user_id=%s : is_connected=%s", last_login.id, user_id, is_connected)
            last_login.is_connected = is_connected
            last_login.save()
        else:
            logger.info("Aucun log existant pour user_id=%s, création d'un nouveau log.", user_id)
            UserLoginHistory.objects.create(user=user, is_connected=is_connected)
    
        return JsonResponse({"success": True, "detail": "Statut de connexion mis à jour."}, status=200)
    
    return JsonResponse({"success": False, "error": "Méthode non autorisée."}, status=405)

@csrf_exempt
def toggle_2fa(request):
    """
    Cette vue met à jour la valeur de 'is_2fa_enabled' dans la base de données
    lorsqu'un utilisateur clique sur le bouton pour activer/désactiver 2FA.
    """
    if request.method == 'POST':
        user_id = request.session.get('user_id')
        if not user_id:
            return JsonResponse({"success": False, "error": "Utilisateur non authentifié."}, status=401)
        
        try:
            user = User42.objects.get(pk=user_id)
        except User42.DoesNotExist:
            return JsonResponse({"success": False, "error": "Utilisateur non trouvé."}, status=404)

        # Inverser la valeur de 'is_2fa_enabled'
        user.is_2fa_enabled = not user.is_2fa_enabled
        user.save()

        return JsonResponse({"success": True, "is_2fa_enabled": user.is_2fa_enabled})
    
    return JsonResponse({"success": False, "error": "Méthode non autorisée."}, status=405)

from django.shortcuts import redirect

class AuthenticationRequiredMiddleware:
    """
    Ce middleware redirige vers /home les requêtes vers des pages protégées
    si l'utilisateur n'est pas authentifié.
    """
    def __init__(self, get_response):
        self.get_response = get_response
        # Définir ici les URL à protéger
        self.protected_paths = ['/board', '/user', '/stats', '/setup']

    def __call__(self, request):
        if request.path in self.protected_paths:
            if not request.session.get('user_id'):
                return redirect('/home')
        response = self.get_response(request)
        return response
from django.contrib import admin
from django.urls import path, include
from oauth_app import views  # Remplacez par le nom correct de l'application contenant la vue
from django.conf import settings
from django.conf.urls.static import static
from conecte_me_backend.views import receive_frontend_log

urlpatterns = [
    path('admin/', admin.site.urls),
    path('auth/', include('oauth_app.urls')),  # Toutes les routes d’authentification et 2FA
    path('auth/42/', include('oauth_app.urls')),  # Routes d’auth OAuth 42
    path('auth/signup/', views.signup_view, name='signup'),  # Ajoutez cette ligne
    
    # AJOUTER la ligne ci-dessous (ou le merge dans votre existant):
    path('auth/login/', views.login_view, name='login'),     # /auth/login/
    path('api/logs/', receive_frontend_log, name='receive_frontend_log'),
]

# Ajout de la configuration pour servir les fichiers médias en développement
if settings.DEBUG:
    urlpatterns += static(settings.MEDIA_URL, document_root=settings.MEDIA_ROOT)import json
import logging
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt

frontend_logger = logging.getLogger("frontend")

@csrf_exempt
def receive_frontend_log(request):
    if request.method == "OPTIONS":
        response = JsonResponse({'status': 'ok'})
        response['Access-Control-Allow-Origin'] = '*'  # À restreindre selon vos besoins
        response['Access-Control-Allow-Methods'] = 'POST, OPTIONS'
        response['Access-Control-Allow-Headers'] = 'Content-Type'
        return response
    elif request.method == "POST":
        try:
            data = json.loads(request.body)
        except json.JSONDecodeError:
            return JsonResponse({"error": "JSON invalide"}, status=400)

        # Vous pouvez ajouter un champ complémentaire sans écraser le "source" envoyé
        data["origin"] = "frontend"  # Si vous souhaitez indiquer que c'est un log frontend
        frontend_logger.info(json.dumps(data))
        response = JsonResponse({"status": "ok"})
        response['Access-Control-Allow-Origin'] = '*'  # En cas de requête cross-domain
        return response
    else:
        return JsonResponse({"error": "Méthode non autorisée"}, status=405)
# backend/conecte_me_backend/settings.py
import os
from pathlib import Path
import logging


# Définition du répertoire de base du projet
BASE_DIR = Path(__file__).resolve().parent.parent

# Clé secrète (à garder secrète en production)
SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY', 'unsafe-secret-key')

# Mode débogage
DEBUG = os.environ.get('DEBUG', '1') == '1'

# Configuration des hôtes autorisés
ALLOWED_HOSTS = os.environ.get('DJANGO_ALLOWED_HOSTS', 'localhost,127.0.0.1,10.31.5.3').split(',')

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'


# Applications installées
INSTALLED_APPS = [
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',

    # Applications tierces
    'rest_framework',
    'oauth2_provider',

    # Applications personnalisées
    'oauth_app',
]

# Middleware
MIDDLEWARE = [
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'conecte_me_backend.middleware.AuthenticationRequiredMiddleware',  # <-- Ajoutez cette ligne
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
]

# Configuration des URL
ROOT_URLCONF = 'conecte_me_backend.urls'

# Configuration des templates
TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [
            BASE_DIR / 'templates',
            BASE_DIR / 'oauth_app' / 'templates',  # Ajout du dossier des templates de 2FA
        ],

        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

# Configuration WSGI
WSGI_APPLICATION = 'conecte_me_backend.wsgi.application'

# Configuration de la base de données
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('POSTGRES_DB', 'conecteme_db'),
        'USER': os.environ.get('POSTGRES_USER', 'conecteme_user'),
        'PASSWORD': os.environ.get('POSTGRES_PASSWORD', 'conecteme_password'),
        'HOST': os.environ.get('POSTGRES_HOST', 'db'),
        'PORT': os.environ.get('POSTGRES_PORT', '5432'),
    }
}

# Configuration Redis
REDIS_HOST = os.environ.get('REDIS_HOST', 'redis')  # Utilise le nom du service dans docker-compose
REDIS_PORT = os.environ.get('REDIS_PORT', '6379')

CACHES = {
    "default": {
        "BACKEND": "django.core.cache.backends.redis.RedisCache",
        "LOCATION": f"redis://{REDIS_HOST}:{REDIS_PORT}/1",
    }
}

# Configuration des mots de passe
AUTH_PASSWORD_VALIDATORS = [
    {'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator'},
    {'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator'},
    {'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator'},
    {'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator'},
]

# Paramètres de localisation
LANGUAGE_CODE = 'fr-fr'
TIME_ZONE = 'Europe/Paris'
USE_I18N = True
USE_L10N = True
USE_TZ = True

# Configuration des fichiers statiques
STATIC_URL = '/static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'

# Configuration des fichiers médias
MEDIA_URL = '/media/'
MEDIA_ROOT = BASE_DIR / 'media'

# Configuration des backends d'authentification
AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend',
    'oauth2_provider.backends.OAuth2Backend',
)

# Configuration des paramètres OAuth2
OAUTH2_PROVIDER = {
    'ACCESS_TOKEN_EXPIRE_SECONDS': 3600,
    'AUTHORIZATION_CODE_EXPIRE_SECONDS': 600,
    'OAUTH2_BACKEND_CLASS': 'oauth2_provider.oauth2_backends.OAuthLibCore',
    'OAUTH2_VALIDATOR_CLASS': 'oauth2_provider.oauth2_validators.OAuth2Validator',
    'SCOPES': {'public': 'Accès public'},
}

REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (
        'oauth2_provider.contrib.rest_framework.OAuth2Authentication',
    ),
}

# Configuration des informations client OAuth2
OAUTH42_WEBSITE = 'https://10.31.5.3:8443'
OAUTH42_CLIENT_ID = 'u-s4t2ud-212adcc9d7bcdde9f1b4072ac7e13a17ce8c3493475514c9c139b3f993a243a6'
OAUTH42_CLIENT_SECRET = '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'
OAUTH42_REDIRECT_URI = 'https://10.31.5.3:8443/auth/42/callback'
OAUTH42_AUTH_URL = 'https://api.intra.42.fr/oauth/authorize'
OAUTH42_TOKEN_URL = 'https://api.intra.42.fr/oauth/token'
OAUTH42_USER_URL = 'https://api.intra.42.fr/v2/me'

# Configuration des e-mails
EMAIL_BACKEND = 'django.core.mail.backends.console.EmailBackend'
DEFAULT_FROM_EMAIL = 'webmaster@localhost'

logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)
logger.debug(f"Connecting to DB: {DATABASES['default']}")

# Définition du répertoire où seront stockés les fichiers de logs.
BASE_DIR = Path(__file__).resolve().parent.parent
LOG_DIR = BASE_DIR / 'logs'
if not LOG_DIR.exists():
    LOG_DIR.mkdir(parents=True, exist_ok=True)

# Configuration de la journalisation (logging) de Django.
# Cette configuration est définie sous forme de dictionnaire et suit le schéma de configuration du module logging de Python.
LOGGING = {
    # Version du schéma de configuration du logging.
    'version': 1,
    'disable_existing_loggers': True,  # Désactive les loggers par défaut
    # Définition des formatters, qui déterminent le format des messages de log.
    'formatters': {
        # Formatter "verbose" : fournit des informations détaillées telles que le niveau, l'heure, le module, l'ID du processus, l'ID du thread et le message.
        'verbose': {
            'format': '{levelname} {asctime} {module} {process:d} {thread:d} {message}',
            'style': '{',  # Utilisation du style "{" pour le formatage
        },
        # Formatter "simple" : affiche seulement le niveau de log et le message.
        'simple': {
            'format': '{levelname} {message}',
            'style': '{',
        },
    },

    # Définition des handlers, qui déterminent où les messages de log seront envoyés.
    'handlers': {
        # Handler "file" : enregistre les logs dans un fichier.
        'file_backend': {
            'level': 'INFO',  # Seuls les messages d'INFO et plus sont enregistrés dans le fichier.
            'class': 'logging.handlers.TimedRotatingFileHandler',
            'filename': str(LOG_DIR / 'django.log'),
            'when': 'D',          # Rotation quotidienne
            'backupCount': 7,     # Conserver les 15 derniers fichiers (15 jours)
            'formatter': 'verbose',
            'delay': True,      # Ouverture du fichier seulement à la première écriture
            'utc': True,        # Utilise l'UTC pour déterminer le rollover
        },
        'file_frontend': {
            'level': 'INFO',
            'class': 'logging.FileHandler',  # Pas de rotation si vous préférez, ou adaptez si nécessaire
            'filename': str(LOG_DIR / 'frontend.log'),
            'formatter': 'verbose',
        },
        # Handler "console" : affiche les logs dans la console (stdout).
        'console': {
            'level': 'DEBUG',  # Affiche tous les messages de DEBUG et plus dans la console.
            'class': 'logging.StreamHandler',  # Utilise StreamHandler pour écrire dans la console.
            'formatter': 'simple',  # Utilise le formatter "simple".
        },
    },

    # Configuration des loggers pour différentes parties de l'application.
    'loggers': {
        # Logger pour Django (les messages émis par Django lui-même).
        'django': {
            'handlers': ['file_backend', 'console'],  # Envoie les logs à la fois dans le fichier et à la console.
            'level': 'INFO',  # Niveau minimum pour enregistrer les messages.
            'propagate': False,  # Empêche la duplication vers le logger racine
        },
        'frontend': {
            'handlers': ['file_frontend', 'console'],
            'level': 'INFO',
            'propagate': False,
        },
    },
}
--- HTML ---

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>ft_transcendence - SPA</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Global CSS (ex. Bootstrap et éventuellement des styles globaux) -->
  <link
    rel="stylesheet"
    href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css"
  />
  <link
    href="https://cdn.jsdelivr.net/npm/bootstrap-icons/font/bootstrap-icons.css"
    rel="stylesheet"
  />
  <link rel="icon" href="static/img/favicon.ico" type="image/x-icon">
  <!-- Vous pouvez aussi ajouter ici un fichier global si besoin -->
</head>
<body>
  <!-- Conteneur unique où l'on injectera les pages dynamiques -->
  <div id="app"></div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
  <!-- Votre router JS et autres scripts -->
  <script src="static/js/router.js"></script>

  <!-- Gestion des erreurs frontend -->
  <script>
    // Fonction d'envoi de log vers le backend
    function sendLog(logData) {
      fetch('/api/logs/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify(logData)
      }).catch(function(error) {
        console.error("Erreur lors de l'envoi du log :", error);
      });
    }

    // Gestion des erreurs globales
    window.onerror = function(message, source, lineno, colno, error) {
      sendLog({
        message: message,
        source: source,
        lineno: lineno,
        colno: colno,
        error: error ? error.stack : null,
        level: 'ERROR'
      });
      // Retourne false pour laisser le navigateur traiter l'erreur normalement
      return false;
    };

    // Gestion des promesses non gérées
    window.onunhandledrejection = function(event) {
      sendLog({
        message: event.reason ? event.reason.toString() : 'Unhandled promise rejection',
        level: 'ERROR',
        source: 'Promise',
        type: 'promise-rejection'
      });
    };

    // Capture des erreurs de ressources (ex: 404, 401) en mode capture
    window.addEventListener('error', function(event) {
      // Si l'événement concerne un élément (ex: <img>, <link>, <script>...) et non une erreur JS globale
      if (event.target && (event.target.src || event.target.href)) {
        const resource = event.target.src || event.target.href;
        sendLog({
          message: 'Erreur de chargement de ressource',
          resource: resource,
          tagName: event.target.tagName,
          level: 'ERROR',
          type: 'resource-error'
        });
      }
    }, true);

    // (Optionnel) Redéfinir console.error pour capturer d'autres logs manuels
    (function(){
      const originalConsoleError = console.error;
      console.error = function(...args) {
        sendLog({
          message: args.join(' '),
          level: 'ERROR',
          type: 'console-error'
        });
        originalConsoleError.apply(console, args);
      };
    })();
  </script>
</body>
</html>

=== Frontend/static/js ===


--- JS ---

// frontend/static/js/router.js
// Inspiré d’un mini-router SPA KISS.

const appDiv = document.querySelector('#app');

// Map “chemin -> Fichier HTML fragment”
// (Vous pouvez adapter : /login => login.html, /signup => signup.html, etc.)
const routes = {
    '/': 'static/templates/home.html',
    '/home': 'static/templates/home.html',
    '/login': 'static/templates/login.html',
    '/signup': 'static/templates/signup.html',
    '/terms': 'static/templates/terms.html',
    '/privacy': 'static/templates/privacy.html',
    '/board': 'static/templates/board.html',
    '/setup': 'static/templates/setup.html',
    '/user': 'static/templates/user.html',
    '/team': 'static/templates/team.html',
    '/stats': 'static/templates/stats.html'
  };

// Définir la liste des routes nécessitant une authentification
const protectedRoutes = ['/board', '/user', '/stats', '/setup'];

function isRouteProtected(path) {
  return protectedRoutes.includes(path);
}

// Fonction qui interroge le backend pour vérifier l'authentification
async function checkAuth() {
  try {
    // On utilise la route '/auth/user/' qui renvoie les infos utilisateur si authentifié
    const res = await fetch('/auth/user/', { method: 'GET', credentials: 'include' });
    if (res.ok) {
      return await res.json();
    }
    return null;
  } catch (error) {
    console.error("Erreur lors de la vérification d'authentification :", error);
    return null;
  }
}


  function loadCSSForRoute(route) {
    return new Promise((resolve, reject) => {
      // Récupère l'ancien <link> s'il existe
      const oldLink = document.getElementById('route-css');
    
      // Détermine le fichier CSS selon la route
      let cssFile;
      if (route === '/login') {
        cssFile = 'static/css/login.css';
      } else if (route === '/signup') {
        cssFile = 'static/css/signup.css';
      } else if (route === '/signin42') {
        cssFile = 'static/css/signup.css';
      } else if (route === '/terms') {
        cssFile = 'static/css/terms.css';
      } else if (route === '/privacy') {
        cssFile = 'static/css/privacy.css';
      } else if (route === '/board') {
        cssFile = 'static/css/board.css';
      } else if (route === '/setup') {
        cssFile = 'static/css/setup.css';
      } else if (route === '/user') {
        cssFile = 'static/css/user.css';
      } else if (route === '/team') {
        cssFile = 'static/css/team.css';
      } else if (route === '/stats') {
        cssFile = 'static/css/stats.css';
      } else {
        cssFile = 'static/css/main.css';
      }
    
      // Crée un nouveau <link> avec un ID temporaire
      const newLink = document.createElement('link');
      newLink.rel = 'stylesheet';
      newLink.href = cssFile;
      newLink.id = 'new-route-css';
    
      // Une fois le CSS chargé, on retire l'ancien et on renomme l'ID
      newLink.onload = () => {
        if (oldLink) {
          oldLink.remove();
        }
        newLink.id = 'route-css';
        resolve();
      };
    
      newLink.onerror = () => {
        reject(new Error('Erreur de chargement du CSS : ' + cssFile));
      };
    
      // Ajoute le nouveau <link> dans le <head>
      document.head.appendChild(newLink);
    });
  }
  
  

  function loadScriptForRoute(route) {
    // Supprimez le script dynamique existant (s'il existe)
    const existingScript = document.getElementById('route-script');
    if (existingScript) {
      existingScript.remove();
    }
    
    let scriptFile;
    if (route === '/login') {
      scriptFile = 'static/js/login.js';
    } else if (route === '/signup') {
      scriptFile = 'static/js/signup.js';
    } else if (route === '/signin42') {
      scriptFile = 'static/js/signin42.js';
    } else if (route === '/board') {
      scriptFile = 'static/js/board.js';
    } else if (route === '/setup') {
      scriptFile = 'static/js/setup.js';
    } else if (route === '/user') {
      scriptFile = 'static/js/user.js';
    // } else if (route === '/stats') {
    //   scriptFile = 'static/js/stats.js';
    } else {
      // Par défaut, chargez le script global
      scriptFile = 'static/js/main.js';
    }
    
    const script = document.createElement('script');
    script.id = 'route-script';
    script.src = scriptFile;
    script.async = false;
    document.body.appendChild(script);
  }

// Fonction principale pour charger une vue
async function navigateTo(path) {
  console.log("Navigating to:", path);

  // Si la route est protégée, vérifier l'authentification
  if (isRouteProtected(path)) {
    const user = await checkAuth();
    if (!user) {
      // Si l'utilisateur n'est pas authentifié, rediriger vers /home
      console.log("Utilisateur non authentifié, redirection vers /home");
      path = '/home';
    }
  }

  // Pour la configuration 2FA, redirige sans SPA
  if (path.startsWith("/auth/2fa/setup")) {
    window.location.href = path;
    return;
  }

  history.pushState({}, '', path);

  // Masque temporairement le contenu pour éviter le FOUC
  appDiv.style.visibility = 'hidden';

  try {
    // Attend que le nouveau CSS soit chargé
    await loadCSSForRoute(path);
  } catch (err) {
    console.error("Erreur lors du chargement du CSS :", err);
  }
  
  const file = routes[path] || routes['/'];
  console.log("Fetching file:", file);
  try {
    const res = await fetch(file, { method: 'GET' });
    if (!res.ok) {
      console.error("Erreur lors du fetch de", file, res.status);
      return;
    }
    const html = await res.text();
    console.log("Contenu récupéré (truncated):", html.substring(0, 100));
    appDiv.innerHTML = html;
    attachListeners();
    loadScriptForRoute(path);
  } catch (err) {
    console.error(err);
  } finally {
    // Révèle le contenu une fois que tout est chargé
    appDiv.style.visibility = 'visible';
  }
}


// Gère le “Back” / “Forward” du navigateur
window.addEventListener('popstate', () => {
  // On relit l’URL actuelle => recharge la vue
  navigateTo(window.location.pathname);
});

// Interception des clics sur liens <a data-link> pour naviguer en SPA
document.addEventListener('click', (e) => {
  const link = e.target.closest('a[data-link]');
  if (link) {
    e.preventDefault();
    navigateTo(link.getAttribute('href'));
  }
});

// Interception de formulaires pour éviter le rechargement total
function attachListeners() {
    const forms = appDiv.querySelectorAll('form');
    
    forms.forEach(form => {
      // Si c'est le formulaire signin42, on le skippe
      if (form.id === 'signin42-form') {
        return;
      }

      // Exclure le formulaire signup pour éviter une double soumission
      if (form.id === 'signup-form') {
        return;
      }

      // Si c'est le formulaire de connexion et qu'il n'a pas d'attribut action, on le définit
      if (form.id === 'loginForm' && !form.getAttribute('action')) {
        form.setAttribute('action', '/auth/login/');
      }
      
      form.addEventListener('submit', (e) => {
        e.preventDefault();
        const url = form.action || window.location.pathname;
        const method = form.method || 'POST';
        const formData = new FormData(form);
        
        fetch(url, { method, body: formData, credentials: 'include' })
          .then(response => response.json())
          .then(data => {
            console.log("Réponse JSON du backend:", data);
            if (data.success && data.redirect) {
              navigateTo(data.redirect);
            }
          })
          .catch(console.error);
      });
    });


  // Exemple: si vous aviez des boutons type "window.location.href = 'signup.html';"
  // On les remplace par un simple: navigateTo('/signup');
  // Remplacement des redirections classiques par navigateTo
  const signupBtn = appDiv.querySelector('#signup-btn');
  if (signupBtn) {
    signupBtn.addEventListener('click', () => {
      navigateTo('/signup');
    });
  }

  const loginBtn = appDiv.querySelector('#login-btn');
  if (loginBtn) {
    loginBtn.addEventListener('click', () => {
      navigateTo('/login');
    });
  }

  const connect42Btn = appDiv.querySelector('#connect-42');
  if (connect42Btn) {
    connect42Btn.addEventListener('click', (e) => {
      const tosCheckbox = document.getElementById('tos-checkbox');
      if (!tosCheckbox || !tosCheckbox.checked) {
        e.preventDefault();
        alert("Vous devez accepter les TOS avant de continuer !");
        return;
      }
      // Redirection directe vers l'endpoint OAuth 42
      window.location.href = '/auth/login-42/';
    });
  }

    // ====== GESTION DE LA CASE À COCHER POUR LES POLITIQUES (TOS & Privacy) ======
    const tosCheckbox = document.getElementById('tos-checkbox');
    if (tosCheckbox && connect42Btn) {
    // Désactiver le bouton dès le chargement de la page
    connect42Btn.disabled = true;
    connect42Btn.classList.add('disabled');

    tosCheckbox.addEventListener('change', () => {
        if (tosCheckbox.checked) {
        connect42Btn.disabled = false;
        connect42Btn.classList.remove('disabled');
        } else {
        connect42Btn.disabled = true;
        connect42Btn.classList.add('disabled');
        }
    });
    }


  // Autres boutons remplacés par navigateTo
  const userIcon = appDiv.querySelector('.user-icon');
  if (userIcon) {
    userIcon.addEventListener('click', () => {
      navigateTo('/user');
    });
  }
  const setupBtn = appDiv.querySelector('#setup-btn');
  if (setupBtn) {
    setupBtn.addEventListener('click', () => {
      navigateTo('/setup');
    });
  }
  const statsBtn = appDiv.querySelector('#stats-btn');
  if (statsBtn) {
    statsBtn.addEventListener('click', () => {
      navigateTo('/stats');
    });
  }
  const creditsBtn = appDiv.querySelector('#credits-btn');
  if (creditsBtn) {
    creditsBtn.addEventListener('click', () => {
      navigateTo('/team');
    });
  }

  const exitBtn = document.getElementById('exit-btn');

  if (exitBtn) {
    exitBtn.addEventListener('click', () => {
      fetch('/auth/logout/', {
        method: 'POST',
        credentials: 'include',
      })
      .then(response => response.json())
      .then(data => {
        console.log("Déconnexion réussie :", data);
        // Redirection vers home.html après la mise à jour
        navigateTo('data.redirect');
      })
      .catch(error => {
        console.error("Erreur lors de la mise à jour du statut :", error);
        navigateTo('/home');
      });
    });
  }
  
  // Etc. Répliquez la logique de vos anciens scripts qui faisaient du "window.location.href"
}

// Au premier chargement, on charge la vue correspondant à la route en cours
// (ex: si l’URL est https://localhost:8443/login, on charge login.html)
navigateTo(window.location.pathname);
const form = document.getElementById('signin42-form');
const passwordInput = document.getElementById('password');
const confirmInput = document.getElementById('confirmPassword');
const submitButton = form.querySelector('button[type="submit"]');
const togglePasswordBtn = document.getElementById('togglePassword');
const toggleConfirmBtn = document.getElementById('toggleConfirmPassword');

// Validation en temps réel
function validateForm() {
  const password = passwordInput.value;
  const confirm = confirmInput.value;
  // Critère : au moins 8 caractères, 1 majuscule, 1 chiffre, 1 caractère spécial
  const pattern = /^(?=.*[A-Z])(?=.*\d)(?=.*[^A-Za-z0-9]).{8,}$/;
  let valid = pattern.test(password) && (password === confirm);
  submitButton.disabled = !valid;
  if (password !== confirm) {
    confirmInput.setCustomValidity("Les mots de passe ne correspondent pas.");
  } else {
    confirmInput.setCustomValidity("");
  }
}

passwordInput.addEventListener('input', validateForm);
confirmInput.addEventListener('input', validateForm);

// Afficher/masquer le mot de passe
togglePasswordBtn.addEventListener('click', () => {
  const type = passwordInput.type === 'password' ? 'text' : 'password';
  passwordInput.type = type;
  togglePasswordBtn.querySelector('i').classList.toggle('bi-eye-slash');
});

toggleConfirmBtn.addEventListener('click', () => {
  const type = confirmInput.type === 'password' ? 'text' : 'password';
  confirmInput.type = type;
  toggleConfirmBtn.querySelector('i').classList.toggle('bi-eye-slash');
});

// Soumission du formulaire
form.addEventListener('submit', (e) => {
  e.preventDefault();

  if (!form.checkValidity()) {
    form.classList.add('was-validated');
    return;
  }

  const formData = new FormData(form);

  fetch('/auth/42/password/', {
    method: 'POST',
    body: formData,
  })
    .then((response) => response.json())
    .then((data) => {
      if (data.success) {
        // Redirige vers l'authentification OAuth 42
        window.location.href = 'https://10.31.5.3:8443/auth/42/login-42/';
      } else {
        alert("Erreur : " + data.error);
      }
    })
    .catch((err) => {
      console.error("Erreur réseau :", err);
      alert("Une erreur réseau s'est produite.");
    });
});  <div class="container d-flex justify-content-center align-items-center min-vh-100">
  <div class="card shadow p-4" style="max-width: 500px; width: 100%;">
    <div class="card-header bg-white text-center">
      <h2 class="mb-0">Définir votre mot de passe</h2>
      <p class="text-muted">Créez un mot de passe pour votre compte 42</p>
    </div>

    <div class="card-body">
      <form id="signin42-form" class="needs-validation" novalidate>
        <!-- Champ Mot de passe -->
        <div class="mb-3">
          <label for="password" class="form-label">Mot de passe</label>
          <div class="input-group">
            <input
              type="password"
              class="form-control"
              id="password"
              name="password"
              required
              minlength="8"
              pattern="(?=.*[A-Z])(?=.*\d)(?=.*[^A-Za-z0-9]).{8,}"
              placeholder="••••••••"
            />
            <button class="btn btn-outline-secondary" type="button" id="togglePassword">
              <i class="bi bi-eye"></i>
            </button>
            <div class="invalid-feedback">
              Le mot de passe doit contenir au moins 8 caractères, une majuscule, un chiffre et un caractère spécial.
            </div>
          </div>
        </div>

        <!-- Champ Confirmation du mot de passe -->
        <div class="mb-3">
          <label for="confirmPassword" class="form-label">Confirmer le mot de passe</label>
          <div class="input-group">
            <input
              type="password"
              class="form-control"
              id="confirmPassword"
              name="confirmPassword"
              required
              minlength="8"
              placeholder="••••••••"
            />
            <button class="btn btn-outline-secondary" type="button" id="toggleConfirmPassword">
              <i class="bi bi-eye"></i>
            </button>
            <div class="invalid-feedback">
              Les mots de passe ne correspondent pas.
            </div>
          </div>
        </div>

        <!-- Bouton de soumission (désactivé par défaut) -->
        <button type="submit" class="btn btn-primary w-100" disabled>
          Valider
        </button>
      </form>
    </div>
  </div>
</div>
